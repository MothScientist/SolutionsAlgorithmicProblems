# A. Равенство подстрок
#
# Ограничение времени: 15 секунд
# Ограничение памяти: 512Mb
#
# Ввод: стандартный ввод или input.txt
# Вывод: стандартный вывод или output.txt
#
# Дана строка S, состоящая из строчных латинских букв.
# Определите, совпадают ли строки одинаковой длины L, начинающиеся с позиций A и B.
#
# Формат ввода:
# В первой строке записана S (1 ≤ |S| ≤ 2 ⋅ 105), состоящая из строчных латинских букв.
# Во второй строке записано число Q (1 ≤ Q ≤ 2 ⋅ 105) — количество запросов.
# В следующих Q строках записаны запросы:
# целые числа L, A и B (1 ≤ L ≤ |S|, 0 ≤ A, B ≤ (|S| - L)) — длина подстрок и позиции, с которых они начинаются.
#
# Формат вывода:
# Если строки совпадают — выведите "yes", иначе — "no".
#
# Пример 1:
# Ввод:
# acabaca
# 3
# 4 3 2
# 3 4 0
# 2 0 1
# Вывод:
# no
# yes
# no
#
# Пример 2:
# Ввод:
# caeabaeadedcbdcdccec
# 10
# 13 4 3
# 2 12 15
# 10 1 3
# 3 8 15
# 13 5 6
# 7 2 6
# 9 8 8
# 19 0 0
# 19 0 0
# 6 7 13
# Вывод:
# no
# no
# no
# no
# no
# no
# yes
# yes
# yes
# no

s = input()
n = len(s)
p = 69996151
x_ = 257
h = [0] * (n+1)  # len(h) = n+1
x = [1] + [0] * n  # len(x) = n+1
s = ' ' + s
for i in range(1, n+1):
    h[i] = (h[i-1] * x_ + ord(s[i])) % p  # хранит хэши для каждой подстроки
    x[i] = (x[i-1] * x_) % p  # хранит степени x


def is_isequal(from_1, from_2, len_s):
    return ((h[from_1 + len_s] + h[from_2] * x[len_s]) % p
            == (h[from_2 + len_s] + h[from_1] * x[len_s]) % p)

# (from_1 + len_s) не выходит за рамки массива, так как массив начинается по сути с 1


k = int(input())
for _ in range(k):
    inp = input().split(" ")
    L = int(inp[0])
    A = int(inp[1])
    B = int(inp[2])
    if is_isequal(A, B, L):
        print("yes")
    else:
        print("no")