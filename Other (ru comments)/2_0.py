# Клумбы

# Алла захотела, чтобы у неё под окном были узкие клумбы с тюльпанами.
# На схеме земельного участка клумбы обозначаются просто горизонтальными отрезками, лежащими на одной прямой.
# Для ландшафтных работ было нанято n садовников. Каждый из них обрабатывал какой-то отрезок на схеме.
# Процесс был организован не очень хорошо,
# иногда один и тот же отрезок или его часть могли быть обработаны сразу несколькими садовниками.
# Таким образом, отрезки, обрабатываемые двумя разными садовниками, сливаются в один.
# Непрерывный обработанный отрезок затем станет клумбой.
# Нужно определить границы будущих клумб.

# Рассмотрим примеры:
# Пример 1:
# Два одинаковых отрезка [7,8] и [7,8] сливаются в один, но потом их накрывает
# отрезок [6,10]. Таким образом, имеем две клумбe с координатами [6,10].

# Пример 2:
# Отрезки [2,3], [3,4] и [3,4] сольются в один отрезок [2,4].
# Формат ввода:
# В первой строке задано количество садовников n. Число садовников не превосходит 100000.

# В следующих n строках через пробел записаны координаты клумб в формате:
# start end, где start - координата начала, end - координата конца.
# Оба числа целые, неотрицательные и не превосходят 107. start строго меньше, чем end.

# Формат вывода:
# Нужно вывести координаты каждой из получившихся клумб в отдельных строках.
# Данные должны выводится в отсортированном порядке - сначала клумбы с меньшими координатами, затем - с бОльшими.

# Ещё примеры:
# 1)
# Ввод:
# 4
# 7 8
# 7 8
# 2 3
# 6 10
# Вывод:
# 2 3
# 6 10

# 2)
# Ввод:
# 4
# 2 3
# 5 6
# 3 4
# 3 4
# Вывод:
# 2 4
# 5 6

def flowers(var, arr):
    seats = arr[0]
    new_com = []
    for i in range(1, var):
        if arr[i][0] <= seats[0] <= arr[i][1] <= seats[1]:  # Нижняя граница добавляется
            seats[0] = arr[i][0]
        elif arr[i][1] >= seats[1] >= arr[i][0] >= seats[0]:  # Верхняя граница добавляется
            seats[1] = arr[i][1]
        elif arr[i][0] <= seats[0] and arr[i][1] >= seats[1]:  # Старый массив полностью входит в новые рамки
            seats[0] = arr[i][0]
            seats[1] = arr[i][1]
        elif arr[i][0] >= seats[0] and arr[i][1] <= seats[1]:  # Случай полного вхождения arr[i] в seats
            pass
        else:
            new_com.append(arr[i])
    if new_com:
        flowers(len(new_com), new_com)
    print(seats[0], seats[1])


n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
flowers(n, a)
